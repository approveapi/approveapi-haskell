{-
   ApproveAPISwagger

   The simple API to request a user's approval on anything via email + sms.

   OpenAPI Version: 3.0.0
   ApproveAPISwagger API version: 1.0.1
   Contact: dev@approveapi.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ApproveApi.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ApproveApi.Model where

import ApproveApi.Core
import ApproveApi.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** LongPoll
newtype LongPoll = LongPoll { unLongPoll :: Bool } deriving (P.Eq, P.Show)

-- * Models


-- ** AnswerMetadata
-- | AnswerMetadata
data AnswerMetadata = AnswerMetadata
  { answerMetadataIpAddress :: !(Maybe Text) -- ^ "ip_address"
  , answerMetadataBrowser :: !(Maybe Text) -- ^ "browser"
  , answerMetadataOperatingSystem :: !(Maybe Text) -- ^ "operating_system"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnswerMetadata
instance A.FromJSON AnswerMetadata where
  parseJSON = A.withObject "AnswerMetadata" $ \o ->
    AnswerMetadata
      <$> (o .:? "ip_address")
      <*> (o .:? "browser")
      <*> (o .:? "operating_system")

-- | ToJSON AnswerMetadata
instance A.ToJSON AnswerMetadata where
  toJSON AnswerMetadata {..} =
   A.object
      [ "ip_address" .= answerMetadataIpAddress
      , "browser" .= answerMetadataBrowser
      , "operating_system" .= answerMetadataOperatingSystem
      ]


-- | Construct a value of type 'AnswerMetadata' (by applying it's required fields, if any)
mkAnswerMetadata
  :: AnswerMetadata
mkAnswerMetadata =
  AnswerMetadata
  { answerMetadataIpAddress = Nothing
  , answerMetadataBrowser = Nothing
  , answerMetadataOperatingSystem = Nothing
  }

-- ** CreatePromptRequest
-- | CreatePromptRequest
data CreatePromptRequest = CreatePromptRequest
  { createPromptRequestUser :: !(Text) -- ^ /Required/ "user" - The user to send the approval request to. Can be either an email address or a phone number.
  , createPromptRequestBody :: !(Text) -- ^ /Required/ "body" - The body of the approval request to show the user.
  , createPromptRequestTitle :: !(Maybe Text) -- ^ "title" - The title of an approval request. Defaults to an empty string.
  , createPromptRequestApproveText :: !(Maybe Text) -- ^ "approve_text" - The approve action text. Defaults to &#39;Approve&#39;.
  , createPromptRequestApproveRedirectUrl :: !(Maybe Text) -- ^ "approve_redirect_url" - An HTTPS URL to redirect the user to if the prompt is approved. This URL is kept secret until the user is redirected to it.
  , createPromptRequestRejectText :: !(Maybe Text) -- ^ "reject_text" - The reject action text. If not specified the reject button will NOT be rendered, and the user will only see an approve action button.
  , createPromptRequestRejectRedirectUrl :: !(Maybe Text) -- ^ "reject_redirect_url" - An HTTPS URL to redirect the user to if the prompt is rejected. This URL is kept secret until the user is redirected to it.
  , createPromptRequestLongPoll :: !(Maybe Bool) -- ^ "long_poll" - If true, the request waits (long-polls) until the user responds to the prompt or more than 10 minutes pass. Defaults to false.
  , createPromptRequestExpiresIn :: !(Maybe Double) -- ^ "expires_in" - The number of seconds until this request can no longer be answered.
  , createPromptRequestMetadata :: !(Maybe PromptMetadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatePromptRequest
instance A.FromJSON CreatePromptRequest where
  parseJSON = A.withObject "CreatePromptRequest" $ \o ->
    CreatePromptRequest
      <$> (o .:  "user")
      <*> (o .:  "body")
      <*> (o .:? "title")
      <*> (o .:? "approve_text")
      <*> (o .:? "approve_redirect_url")
      <*> (o .:? "reject_text")
      <*> (o .:? "reject_redirect_url")
      <*> (o .:? "long_poll")
      <*> (o .:? "expires_in")
      <*> (o .:? "metadata")

-- | ToJSON CreatePromptRequest
instance A.ToJSON CreatePromptRequest where
  toJSON CreatePromptRequest {..} =
   A.object
      [ "user" .= createPromptRequestUser
      , "body" .= createPromptRequestBody
      , "title" .= createPromptRequestTitle
      , "approve_text" .= createPromptRequestApproveText
      , "approve_redirect_url" .= createPromptRequestApproveRedirectUrl
      , "reject_text" .= createPromptRequestRejectText
      , "reject_redirect_url" .= createPromptRequestRejectRedirectUrl
      , "long_poll" .= createPromptRequestLongPoll
      , "expires_in" .= createPromptRequestExpiresIn
      , "metadata" .= createPromptRequestMetadata
      ]


-- | Construct a value of type 'CreatePromptRequest' (by applying it's required fields, if any)
mkCreatePromptRequest
  :: Text -- ^ 'createPromptRequestUser': The user to send the approval request to. Can be either an email address or a phone number.
  -> Text -- ^ 'createPromptRequestBody': The body of the approval request to show the user.
  -> CreatePromptRequest
mkCreatePromptRequest createPromptRequestUser createPromptRequestBody =
  CreatePromptRequest
  { createPromptRequestUser
  , createPromptRequestBody
  , createPromptRequestTitle = Nothing
  , createPromptRequestApproveText = Nothing
  , createPromptRequestApproveRedirectUrl = Nothing
  , createPromptRequestRejectText = Nothing
  , createPromptRequestRejectRedirectUrl = Nothing
  , createPromptRequestLongPoll = Nothing
  , createPromptRequestExpiresIn = Nothing
  , createPromptRequestMetadata = Nothing
  }

-- ** Error
-- | Error
data Error = Error
  { errorError :: !(Text) -- ^ /Required/ "error" - A human readable API error message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "error")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   A.object
      [ "error" .= errorError
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Text -- ^ 'errorError': A human readable API error message.
  -> Error
mkError errorError =
  Error
  { errorError
  }

-- ** Prompt
-- | Prompt
data Prompt = Prompt
  { promptId :: !(Text) -- ^ /Required/ "id" - A unique id for this prompt.
  , promptSentAt :: !(Double) -- ^ /Required/ "sent_at" - The unix timestamp when this prompt was sent.
  , promptIsExpired :: !(Bool) -- ^ /Required/ "is_expired" - Whether the prompt can still be answered.
  , promptAnswer :: !(Maybe PromptAnswer) -- ^ "answer"
  , promptMetadata :: !(Maybe PromptMetadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Prompt
instance A.FromJSON Prompt where
  parseJSON = A.withObject "Prompt" $ \o ->
    Prompt
      <$> (o .:  "id")
      <*> (o .:  "sent_at")
      <*> (o .:  "is_expired")
      <*> (o .:? "answer")
      <*> (o .:? "metadata")

-- | ToJSON Prompt
instance A.ToJSON Prompt where
  toJSON Prompt {..} =
   A.object
      [ "id" .= promptId
      , "sent_at" .= promptSentAt
      , "is_expired" .= promptIsExpired
      , "answer" .= promptAnswer
      , "metadata" .= promptMetadata
      ]


-- | Construct a value of type 'Prompt' (by applying it's required fields, if any)
mkPrompt
  :: Text -- ^ 'promptId': A unique id for this prompt.
  -> Double -- ^ 'promptSentAt': The unix timestamp when this prompt was sent.
  -> Bool -- ^ 'promptIsExpired': Whether the prompt can still be answered.
  -> Prompt
mkPrompt promptId promptSentAt promptIsExpired =
  Prompt
  { promptId
  , promptSentAt
  , promptIsExpired
  , promptAnswer = Nothing
  , promptMetadata = Nothing
  }

-- ** PromptAnswer
-- | PromptAnswer
data PromptAnswer = PromptAnswer
  { promptAnswerResult :: !(Bool) -- ^ /Required/ "result" - The user&#39;s answer to whether or not they approve this prompt.
  , promptAnswerTime :: !(Double) -- ^ /Required/ "time" - The unix timestamp when the user answered the prompt.
  , promptAnswerMetadata :: !(Maybe AnswerMetadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromptAnswer
instance A.FromJSON PromptAnswer where
  parseJSON = A.withObject "PromptAnswer" $ \o ->
    PromptAnswer
      <$> (o .:  "result")
      <*> (o .:  "time")
      <*> (o .:? "metadata")

-- | ToJSON PromptAnswer
instance A.ToJSON PromptAnswer where
  toJSON PromptAnswer {..} =
   A.object
      [ "result" .= promptAnswerResult
      , "time" .= promptAnswerTime
      , "metadata" .= promptAnswerMetadata
      ]


-- | Construct a value of type 'PromptAnswer' (by applying it's required fields, if any)
mkPromptAnswer
  :: Bool -- ^ 'promptAnswerResult': The user's answer to whether or not they approve this prompt.
  -> Double -- ^ 'promptAnswerTime': The unix timestamp when the user answered the prompt.
  -> PromptAnswer
mkPromptAnswer promptAnswerResult promptAnswerTime =
  PromptAnswer
  { promptAnswerResult
  , promptAnswerTime
  , promptAnswerMetadata = Nothing
  }

-- ** PromptMetadata
-- | PromptMetadata
data PromptMetadata = PromptMetadata
  { promptMetadataLocation :: !(Maybe Text) -- ^ "location" - The physical location, like Oakland, CA, of the action.
  , promptMetadataTime :: !(Maybe Text) -- ^ "time" - The date/time of the action.
  , promptMetadataIpAddress :: !(Maybe Text) -- ^ "ip_address" - The IP address of the computer initiating the action.
  , promptMetadataBrowser :: !(Maybe Text) -- ^ "browser" - The web browser initiating the action, i.e. Chrome.
  , promptMetadataOperatingSystem :: !(Maybe Text) -- ^ "operating_system" - The operating system initiating the action, i.e. Mac OS X.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromptMetadata
instance A.FromJSON PromptMetadata where
  parseJSON = A.withObject "PromptMetadata" $ \o ->
    PromptMetadata
      <$> (o .:? "location")
      <*> (o .:? "time")
      <*> (o .:? "ip_address")
      <*> (o .:? "browser")
      <*> (o .:? "operating_system")

-- | ToJSON PromptMetadata
instance A.ToJSON PromptMetadata where
  toJSON PromptMetadata {..} =
   A.object
      [ "location" .= promptMetadataLocation
      , "time" .= promptMetadataTime
      , "ip_address" .= promptMetadataIpAddress
      , "browser" .= promptMetadataBrowser
      , "operating_system" .= promptMetadataOperatingSystem
      ]


-- | Construct a value of type 'PromptMetadata' (by applying it's required fields, if any)
mkPromptMetadata
  :: PromptMetadata
mkPromptMetadata =
  PromptMetadata
  { promptMetadataLocation = Nothing
  , promptMetadataTime = Nothing
  , promptMetadataIpAddress = Nothing
  , promptMetadataBrowser = Nothing
  , promptMetadataOperatingSystem = Nothing
  }

-- ** PromptStatus
-- | PromptStatus
data PromptStatus = PromptStatus
  { promptStatusIsAnswered :: !(Bool) -- ^ /Required/ "is_answered" - Whether the prompt has been answered or not.
  , promptStatusIsExpired :: !(Bool) -- ^ /Required/ "is_expired" - Whether the prompt can still be answered.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromptStatus
instance A.FromJSON PromptStatus where
  parseJSON = A.withObject "PromptStatus" $ \o ->
    PromptStatus
      <$> (o .:  "is_answered")
      <*> (o .:  "is_expired")

-- | ToJSON PromptStatus
instance A.ToJSON PromptStatus where
  toJSON PromptStatus {..} =
   A.object
      [ "is_answered" .= promptStatusIsAnswered
      , "is_expired" .= promptStatusIsExpired
      ]


-- | Construct a value of type 'PromptStatus' (by applying it's required fields, if any)
mkPromptStatus
  :: Bool -- ^ 'promptStatusIsAnswered': Whether the prompt has been answered or not.
  -> Bool -- ^ 'promptStatusIsExpired': Whether the prompt can still be answered.
  -> PromptStatus
mkPromptStatus promptStatusIsAnswered promptStatusIsExpired =
  PromptStatus
  { promptStatusIsAnswered
  , promptStatusIsExpired
  }




-- * Auth Methods

-- ** AuthBasicApiKey
data AuthBasicApiKey =
  AuthBasicApiKey B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicApiKey where
  applyAuthMethod _ a@(AuthBasicApiKey user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


